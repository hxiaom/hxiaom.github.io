---
layout: post
title: 【Method】循环网络（三）循环神经网络
categories: Analytics
sidebar: toc
---

## 原理

基于图展开和参数共享的思想，我们可以设计各种循环神经网络。

循环神经网络中一些重要的设计模式包括以下几种：

（1）每个时间步都有输出，并且隐藏单元之间有循环连接的循环网络；

（2）每个时间步都产生一个输出，只有当前时刻的输出到下个时刻的隐藏单元之间有循环连接的循环网络；

（3）隐藏单元之间存在循环连接，但读取整个序列后产生单个输出的循环网络。

任何图灵可计算的函数都可以通过这样一个有限维的循环网络计算，在这个意义上，循环神经网络是万能的。RNN经过若干时间步后读取输出，这与由图灵机所用的时间步是渐进线性的，与输入长度也是渐进线性的（Siegelmann and Sontag, 1991）。由图灵机计算的函数是离散的，所以这些结果都是函数的具体实现，而不是近似。RNN作为图灵机使用时，需要一个二进制序列作为输入，其输出必须离散化以提供二进制输出。利用单个有限大小的特定RNN计算在此设置下的所有函数是可能的（Siegelmann and Sontag（1995）用了866个单元）。图灵机的”输入“是要计算函数的详细说明（specification），所以模拟此图灵机的相同网络足以应付所有问题。用于证明的理论RNN可以通过激活和权重（由无限精度的有理数表示）来模拟无限堆栈。

现在我们研究RNN的前向传播公式。这个图没有指定隐藏单元的激活函数。假设使用双曲正切激活函数。此外，图中没有明确指定何种形式的输出和损失函数。假定输出是离散的，如用于预测词或字符的RNN。表示离散变量的常规方式是把输出o作为每个离散变量可能值的非标准化对数概率。然后，我们可以应用softmax函数后续处理后，获得标准化后概率的输出向量$$\hat{y}$$。RNN从特定的初始状态$$h^{(0)}$$开始前向传播。从t=1到$$t=\tau$$的每个时间步，我们应用以下更新方程：

$$\begin{align}
a^{(t)} &= b+ Wh^{(t-1)} + Ux^{(t)} \\
h^{(t)} &= tanh(a^{(t)}) \\
o^{(t)} &= c + Vh^{(t)} \\
\hat{y}^{(t)} &= softmax(o^{(t)}) \\
\end{align}$$

其中的参数的偏置向量b和c连同权重矩阵U、V和W，分别对应于输入到隐藏、隐藏到输出和隐藏到隐藏的连接。这个循环网络将一个输入序列映射到相同长度的输出序列。与x序列配对的y的总损失就是所有时间步的损失之和。例如，$$L^{(t)}$$为给定的$$x^{(1)},...,x^{(t)}$$后$$y^{(t)}$$的负对数似然，则

$$\begin{align}
& L({x^{(1)},...,x^{(\tau)}}, {y^{(1)},...,y^{(\tau)}}) \\
&= \sum_t L^{(t)} \\
&= -\sum_t log p_{model} (y^{(t)} \mid {x^{(1)},...,x^{(\tau)}}) \\
\end{align}$$

其中$$p_{model}(y^{(t)} \mid {x^{(1)},...,x^{(\tau)}})$$需要读取模型输入向量$$\hat{y}^{(t)}$$中对应于$$y^{(t)}$$的项。关于各个参数计算这个损失函数的梯度是计算成本很高的操作。梯度计算涉及执行一次前向传播，接着是由右到左的反向传播。运行时间是$$O(\tau)$$，并且不能通过并行化来降低，因为前向传播图是固有循序的；每个时间步只能一前一后地计算。前向传播中的各个状态必须保存，直到它们反向传播中被再次使用，因此内存代价也是$$O(\tau)$$。应用于展开图且代价为$$O(\tau)$$的反向传播算法称为通过时间反向传播（back-propagation through time, BPTT）。因此隐藏单元之间存在循环的网络非常强大但训练代价也很大。

### 导师驱动过程和输出循环网络

仅在一个时间步的输出和下一个时间步的隐藏单元间存在循环连接的网络确实没有那么强大（因为缺乏隐藏到隐藏的循环连接）。例如，它不能模拟通用图灵机。因为这个网络缺少隐藏到隐藏的循环，它要求输出单元捕捉用于预测未来的关于过去的所有信息。因为输出单元明确地训练成匹配训练集的目标，它们不太能捕获关于过去输入历史的必要信息，除非用户知道如何描述系统的全部状态，并将它作为训练目标的一部分。消除隐藏到隐藏循环的优点在于，任何基于比较时刻t的预测和时刻t的训练目标的损失函数中的所有时间步都解耦了。因此训练可以并行化，即在各时刻t分别计算梯度。因为训练集提供输出的理想值，所以没有必要先计算前一时刻的输出。

由输出反馈到模型而产生循环连接的模型可用导师驱动过程（teacher forcing）进行训练。训练模型时，导师驱动过程不再使用最大似然准则，而在时刻t+1接收真实值$$y^{(t)}$$作为输入。我们可以通过检查两个时间步的序列得知这一点。条件最大似然准则是

$$\begin{align}
& log p(y^{(1)}, y^{(2)} \mid x^{(1)}, x^{(2)}) \\
&= log p(y^{(2)} \mid y^{(1)}, x^{(1)}, x^{(2)}) + log p(y^{(1)} \mid x^{(1)}, x^{(2)}) \\
\end{align}$$